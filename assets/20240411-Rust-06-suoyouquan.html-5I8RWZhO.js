import{_ as o,r as p,o as c,c as i,a as n,b as s,d as e,e as t}from"./app-C4bsKav7.js";const l={},r=n("h1",{id:"所有权",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#所有权","aria-hidden":"true"},"#"),s(" 所有权")],-1),u=n("blockquote",null,[n("p",null,"所有权（系统）是 Rust 最为与众不同的特性，它让 Rust 无需垃圾回收器（garbage collector）即可保证内存安全。因此，理解 Rust 中所有权的运作方式非常重要。在本章中，我们将讨论所有权以及相关功能：借用、slice 以及 Rust 如何在内存中存放数据。")],-1),d={id:"什么是所有权",tabindex:"-1"},k=n("a",{class:"header-anchor",href:"#什么是所有权","aria-hidden":"true"},"#",-1),m={href:"https://www.rustwiki.org.cn/zh-CN/book/ch04-01-what-is-ownership.html#%E4%BB%80%E4%B9%88%E6%98%AF%E6%89%80%E6%9C%89%E6%9D%83",target:"_blank",rel:"noopener noreferrer"},v=n("p",null,[s("Rust 的核心功能（之一）是 "),n("strong",null,"所有权"),s("（"),n("em",null,"ownership"),s("）。虽然该功能很容易解释，但它对语言的其他部分有着深刻的影响。")],-1),h=n("p",null,"所有运行的程序都必须管理其使用计算机内存的方式。一些语言中具有垃圾回收机制，在程序运行时不断地寻找不再使用的内存；在另一些语言中，开发者必须亲自分配和释放内存。Rust 则选择了第三种方式：通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查。在运行时，所有权系统的任何功能都不会减慢程序。",-1),g=n("p",null,"因为所有权对很多开发者来说都是一个新概念，需要一些时间来适应。好消息是随着你对 Rust 和所有权系统的规则越来越有经验，你就越能自然地编写出安全和高效的代码。持之以恒！",-1),b=n("p",null,"当你理解了所有权，你将有一个坚实的基础来理解那些使 Rust 独特的功能。在本章中，你将通过完成一些示例来学习所有权，这些示例基于一个常用的数据结构：字符串。",-1),_={id:"栈-stack-与堆-heap",tabindex:"-1"},w=n("a",{class:"header-anchor",href:"#栈-stack-与堆-heap","aria-hidden":"true"},"#",-1),f={href:"https://www.rustwiki.org.cn/zh-CN/book/ch04-01-what-is-ownership.html#%E6%A0%88stack%E4%B8%8E%E5%A0%86heap",target:"_blank",rel:"noopener noreferrer"},E=t("<p>在很多语言中，你并不需要经常考虑到栈与堆。不过在像 Rust 这样的系统编程语言中，值是位于栈上还是堆上在更大程度上影响了语言的行为以及为何必须做出这样的抉择。我们会在本章的稍后部分描述所有权与栈和堆相关的内容，所以这里只是一个用来预热的简要解释。</p><p>栈和堆都是代码在运行时可供使用的内存，但是它们的结构不同。栈以放入值的顺序存储值并以相反顺序取出值。这也被称作 <strong>后进先出</strong>（<em>last in, first out</em>）。想象一下一叠盘子：当增加更多盘子时，把它们放在盘子堆的顶部，当需要盘子时，也从顶部拿走。不能从中间也不能从底部增加或拿走盘子！增加数据叫做 <strong>进栈</strong>（<em>pushing onto the stack</em>），而移出数据叫做 <strong>出栈</strong>（<em>popping off the stack</em>）。</p><p>栈中的所有数据都必须占用已知且固定的大小。在编译时大小未知或大小可能变化的数据，要改为存储在堆上。堆是缺乏组织的：当向堆放入数据时，你要请求一定大小的空间。内存分配器（memory allocator）在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的 <strong>指针</strong>（<em>pointer</em>）。这个过程称作 <strong>在堆上分配内存</strong>（<em>allocating on the heap</em>），有时简称为 “分配”（allocating）。将数据推入栈中并不被认为是分配。因为指针的大小是已知并且固定的，你可以将指针存储在栈上，不过当需要实际数据时，必须访问指针。</p><p>想象一下去餐馆就座吃饭。当进入时，你说明有几个人，餐馆员工会找到一个够大的空桌子并领你们过去。如果有人来迟了，他们也可以通过询问来找到你们坐在哪。</p><p>入栈比在堆上分配内存要快，因为（入栈时）分配器无需为存储新数据去搜索内存空间；其位置总是在栈顶。相比之下，在堆上分配内存则需要更多的工作，这是因为分配器必须首先找到一块足够存放数据的内存空间，并接着做一些记录为下一次分配做准备。</p><p>访问堆上的数据比访问栈上的数据慢，因为必须通过指针来访问。现代处理器在内存中跳转越少就越快（缓存）。继续类比，假设有一个服务员在餐厅里处理多个桌子的点菜。在一个桌子报完所有菜后再移动到下一个桌子是最有效率的。从桌子 A 听一个菜，接着桌子 B 听一个菜，然后再桌子 A，然后再桌子 B 这样的流程会更加缓慢。出于同样原因，处理器在处理的数据彼此较近的时候（比如在栈上）比较远的时候（比如可能在堆上）能更好的工作。在堆上分配大量的空间也可能消耗时间。</p><p>当你的代码调用一个函数时，传递给函数的值（包括可能指向堆上数据的指针）和函数的局部变量被压入栈中。当函数结束时，这些值被移出栈。</p><p>跟踪哪部分代码正在使用堆上的哪些数据，最大限度的减少堆上的重复数据的数量，以及清理堆上不再使用的数据确保不会耗尽空间，这些问题正是所有权系统要处理的。一旦理解了所有权，你就不需要经常考虑栈和堆了，不过明白了所有权的存在就是为了管理堆数据，能够帮助解释为什么所有权要以这种方式工作。</p>",8),y={id:"所有权规则",tabindex:"-1"},x=n("a",{class:"header-anchor",href:"#所有权规则","aria-hidden":"true"},"#",-1),q={href:"https://www.rustwiki.org.cn/zh-CN/book/ch04-01-what-is-ownership.html#%E6%89%80%E6%9C%89%E6%9D%83%E8%A7%84%E5%88%99",target:"_blank",rel:"noopener noreferrer"},C=n("p",null,"首先，让我们看一下所有权的规则。当我们通过举例说明时，请谨记这些规则：",-1),B=n("ul",null,[n("li",null,[s("Rust 中的每一个值都有一个被称为其 "),n("strong",null,"所有者"),s("（"),n("em",null,"owner"),s("）的变量。")]),n("li",null,"值在任一时刻有且只有一个所有者。"),n("li",null,"当所有者（变量）离开作用域，这个值将被丢弃。")],-1),S={id:"变量作用域",tabindex:"-1"},A=n("a",{class:"header-anchor",href:"#变量作用域","aria-hidden":"true"},"#",-1),R={href:"https://www.rustwiki.org.cn/zh-CN/book/ch04-01-what-is-ownership.html#%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F",target:"_blank",rel:"noopener noreferrer"},N=t(`<p>在所有权的第一个例子中，我们看看一些变量的 <strong>作用域</strong>（<em>scope</em>）。作用域是一个项（item）在程序中有效的范围。假设有这样一个变量：</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>变量 <code>s</code> 绑定到了一个字符串字面量，这个字符串值是硬编码进程序代码中的。这个变量从声明的点开始直到当前 <strong>作用域</strong> 结束时都是有效的。示例 4-1 的注释标明了变量 <code>s</code> 在何处是有效的。</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code>    <span class="token punctuation">{</span>                      <span class="token comment">// s 在这里无效, 它尚未声明</span>
        <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>   <span class="token comment">// 从此处起，s 开始有效</span>

        <span class="token comment">// 使用 s</span>
    <span class="token punctuation">}</span>                      <span class="token comment">// 此作用域已结束，s 不再有效</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>示例 4-1：一个变量和其有效的作用域</p><p>换句话说，这里有两个重要的时间点：</p><ul><li>当 <code>s</code> <strong>进入作用域</strong> 时，它就是有效的。</li><li>这一直持续到它 <strong>离开作用域</strong> 为止。</li></ul><p>目前为止，变量是否有效与作用域的关系跟其他编程语言是类似的。现在我们在此基础上介绍 <code>String</code> 类型。</p>`,8),z={id:"string-类型",tabindex:"-1"},F=n("a",{class:"header-anchor",href:"#string-类型","aria-hidden":"true"},"#",-1),D={href:"https://www.rustwiki.org.cn/zh-CN/book/ch04-01-what-is-ownership.html#string-%E7%B1%BB%E5%9E%8B",target:"_blank",rel:"noopener noreferrer"},I=n("code",null,"String",-1),V=t(`<p>我们已经见过字符串字面量，即被硬编码进程序里的字符串值。字符串字面量是很方便的，不过它们并不适合使用文本的每一种场景。原因之一就是它们是不可变的。另一个原因是并非所有字符串的值都能在编写代码时就知道：例如，要是想获取用户输入并存储该怎么办呢？为此，Rust 有第二个字符串类型，<code>String</code>。这个类型管理被分配到堆上的数据，所以能够存储在编译时未知大小的文本。可以使用 <code>from</code> 函数基于字符串字面量来创建 <code>String</code>，如下：</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,2),G=n("code",null,"::",-1),L=n("code",null,"from",-1),T=n("code",null,"String",-1),j=n("code",null,"string_from",-1),H={href:"https://www.rustwiki.org.cn/zh-CN/book/ch05-03-method-syntax.html#%E6%96%B9%E6%B3%95%E8%AF%AD%E6%B3%95",target:"_blank",rel:"noopener noreferrer"},M={href:"https://www.rustwiki.org.cn/zh-CN/book/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html",target:"_blank",rel:"noopener noreferrer"},$=t(`<p><strong>可以</strong> 修改此类字符串 ：</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code>    <span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    s<span class="token punctuation">.</span><span class="token function">push_str</span><span class="token punctuation">(</span><span class="token string">&quot;, world!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// push_str() 在字符串后追加字面值</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{}&quot;</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将打印 \`hello, world!\`</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么这里有什么区别呢？为什么 <code>String</code> 可变而字面量却不行呢？区别在于两个类型对内存的处理上。</p>`,3),J={id:"内存与分配",tabindex:"-1"},K=n("a",{class:"header-anchor",href:"#内存与分配","aria-hidden":"true"},"#",-1),O={href:"https://www.rustwiki.org.cn/zh-CN/book/ch04-01-what-is-ownership.html#%E5%86%85%E5%AD%98%E4%B8%8E%E5%88%86%E9%85%8D",target:"_blank",rel:"noopener noreferrer"},P=t(`<p>就字符串字面量来说，我们在编译时就知道其内容，所以文本被直接硬编码进最终的可执行文件中。这使得字符串字面量快速且高效。不过这些特性都只得益于字符串字面量的不可变性。不幸的是，我们不能为了每一个在编译时大小未知的文本而将一块内存放入二进制文件中，并且它的大小还可能随着程序运行而改变。</p><p>对于 <code>String</code> 类型，为了支持一个可变，可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。这意味着：</p><ul><li>必须在运行时向内存分配器请求内存。</li><li>需要一个当我们处理完 <code>String</code> 时将内存返回给分配器的方法。</li></ul><p>第一部分由我们完成：当调用 <code>String::from</code> 时，它的实现 (<em>implementation</em>) 请求其所需的内存。这在编程语言中是非常通用的。</p><p>然而，第二部分实现起来就各有区别了。在有 <strong>垃圾回收</strong>（<em>garbage collector</em>，<em>GC</em>）的语言中， GC 记录并清除不再使用的内存，而我们并不需要关心它。没有 GC 的话，识别出不再使用的内存并调用代码显式释放就是我们的责任了，跟请求内存的时候一样。从历史的角度上说正确处理内存回收曾经是一个困难的编程问题。如果忘记回收了会浪费内存。如果过早回收了，将会出现无效变量。如果重复回收，这也是个 bug。我们需要精确的为一个 <code>allocate</code> 配对一个 <code>free</code>。</p><p>Rust 采取了一个不同的策略：内存在拥有它的变量离开作用域后就被自动释放。下面是示例 4-1 中作用域例子的一个使用 <code>String</code> 而不是字符串字面量的版本：</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code>    <span class="token punctuation">{</span>
        <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 从此处起，s 开始有效</span>

        <span class="token comment">// 使用 s</span>
    <span class="token punctuation">}</span>                                  <span class="token comment">// 此作用域已结束，</span>
                                       <span class="token comment">// s 不再有效</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,7),Q=n("code",null,"String",-1),U=n("code",null,"s",-1),W={href:"https://www.rustwiki.org.cn/zh-CN/std/ops/trait.Drop.html#tymethod.drop",target:"_blank",rel:"noopener noreferrer"},X=n("code",null,"drop",-1),Y=n("code",null,"String",-1),Z=n("code",null,"}",-1),nn=n("code",null,"drop",-1),sn=n("blockquote",null,[n("p",null,[s("注意：在 C++ 中，这种 item 在生命周期结束时释放资源的模式有时被称作 "),n("strong",null,"资源获取即初始化"),s("（"),n("em",null,"Resource Acquisition Is Initialization (RAII)"),s("）。如果你使用过 RAII 模式的话应该对 Rust 的 "),n("code",null,"drop"),s(" 函数并不陌生。")])],-1),an=n("p",null,"这个模式对编写 Rust 代码的方式有着深远的影响。现在它看起来很简单，不过在更复杂的场景下代码的行为可能是不可预测的，比如当有多个变量使用在堆上分配的内存时。现在让我们探索一些这样的场景。",-1),en={id:"变量与数据交互的方式-一-移动",tabindex:"-1"},tn=n("a",{class:"header-anchor",href:"#变量与数据交互的方式-一-移动","aria-hidden":"true"},"#",-1),on={href:"https://www.rustwiki.org.cn/zh-CN/book/ch04-01-what-is-ownership.html#%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E7%9A%84%E6%96%B9%E5%BC%8F%E4%B8%80%E7%A7%BB%E5%8A%A8",target:"_blank",rel:"noopener noreferrer"},pn=t(`<p>在 Rust 中，多个变量能够以不同的方式与同一数据交互。让我们看看示例 4-2 中一个使用整型的例子。</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code>    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>示例 4-2：将变量 <code>x</code> 的整数值赋给 <code>y</code></p><p>我们大致可以猜到这在干什么：“将 <code>5</code> 绑定到 <code>x</code>；接着生成一个值 <code>x</code> 的拷贝并绑定到 <code>y</code>”。现在有了两个变量，<code>x</code> 和 <code>y</code>，都等于 <code>5</code>。这也正是事实上发生了的，因为整数是有已知固定大小的简单值，所以这两个 <code>5</code> 被放入了栈中。</p><p>现在看看这个 <code>String</code> 版本：</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code>    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这看起来与上面的代码非常类似，所以我们可能会假设他们的运行方式也是类似的：也就是说，第二行可能会生成一个 <code>s1</code> 的拷贝并绑定到 <code>s2</code> 上。不过，事实上并不完全是这样。</p><p>看看图 4-1 以了解 <code>String</code> 的底层会发生什么。<code>String</code> 由三部分组成，如图左侧所示：一个指向存放字符串内容内存的指针，一个长度，和一个容量。这一组数据存储在栈上。右侧则是堆上存放内容的内存部分。</p><p><img src="https://www.rustwiki.org.cn/zh-CN/book/img/trpl04-01.svg" alt="String in memory"></p><p>图 4-1：将值 <code>&quot;hello&quot;</code> 绑定给 <code>s1</code> 的 <code>String</code> 在内存中的表现形式</p><p>长度表示 <code>String</code> 的内容当前使用了多少字节的内存。容量是 <code>String</code> 从分配器总共获取了多少字节的内存。长度与容量的区别是很重要的，不过在当前上下文中并不重要，所以现在可以忽略容量。</p><p>当我们将 <code>s1</code> 赋值给 <code>s2</code>，<code>String</code> 的数据被复制了，这意味着我们从栈上拷贝了它的指针、长度和容量。我们并没有复制指针指向的堆上数据。换句话说，内存中数据的表现如图 4-2 所示。</p><p><img src="https://www.rustwiki.org.cn/zh-CN/book/img/trpl04-02.svg" alt="s1 and s2 pointing to the same value"></p><p>图 4-2：变量 <code>s2</code> 的内存表现，它有一份 <code>s1</code> 指针、长度和容量的拷贝</p><p>这个表现形式看起来 <strong>并不像</strong> 图 4-3 中的那样，如果 Rust 也拷贝了堆上的数据，那么内存看起来就是这样的。如果 Rust 这么做了，那么操作 <code>s2 = s1</code> 在堆上数据比较大的时候会对运行时性能造成非常大的影响。</p><p><img src="https://www.rustwiki.org.cn/zh-CN/book/img/trpl04-03.svg" alt="s1 and s2 to two places"></p><p>图 4-3：另一个 <code>s2 = s1</code> 时可能的内存表现，如果 Rust 同时也拷贝了堆上的数据的话</p><p>之前我们提到过当变量离开作用域后，Rust 自动调用 <code>drop</code> 函数并清理变量的堆内存。不过图 4-2 展示了两个数据指针指向了同一位置。这就有了一个问题：当 <code>s2</code> 和 <code>s1</code> 离开作用域，他们都会尝试释放相同的内存。这是一个叫做 <strong>二次释放</strong>（<em>double free</em>）的错误，也是之前提到过的内存安全性 bug 之一。两次释放（相同）内存会导致内存污染，它可能会导致潜在的安全漏洞。</p><p>为了确保内存安全，这种场景下 Rust 的处理有另一个细节值得注意。在 <code>let s2 = s1</code> 之后，Rust 认为 <code>s1</code> 不再有效，因此 Rust 不需要在 <code>s1</code> 离开作用域后清理任何东西。看看在 <code>s2</code> 被创建之后尝试使用 <code>s1</code> 会发生什么；这段代码不能运行：</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code>    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">;</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{}, world!&quot;</span><span class="token punctuation">,</span> s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你会得到一个类似如下的错误，因为 Rust 禁止你使用无效的引用。</p><div class="language-console line-numbers-mode" data-ext="console"><pre class="language-console"><code>$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: \`s1\`
 --&gt; src/main.rs:5:28
  |
2 |     let s1 = String::from(&quot;hello&quot;);
  |         -- move occurs because \`s1\` has type \`String\`, which does not implement the \`Copy\` trait
3 |     let s2 = s1;
  |              -- value moved here
4 | 
5 |     println!(&quot;{}, world!&quot;, s1);
  |                            ^^ value borrowed here after move

For more information about this error, try \`rustc --explain E0382\`.
error: could not compile \`ownership\` due to previous error
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你在其他语言中听说过术语 <strong>浅拷贝</strong>（<em>shallow copy</em>）和 <strong>深拷贝</strong>（<em>deep copy</em>），那么拷贝指针、长度和容量而不拷贝数据可能听起来像浅拷贝。不过因为 Rust 同时使第一个变量无效了，这个操作被称为 <strong>移动</strong>（<em>move</em>），而不是浅拷贝。上面的例子可以解读为 <code>s1</code> 被 <strong>移动</strong> 到了 <code>s2</code> 中。那么具体发生了什么，如图 4-4 所示。</p><p><img src="https://www.rustwiki.org.cn/zh-CN/book/img/trpl04-04.svg" alt="s1 moved to s2"></p><p>图 4-4：<code>s1</code> 无效之后的内存表现</p><p>这样就解决了我们的问题！因为只有 <code>s2</code> 是有效的，当其离开作用域，它就释放自己的内存，完毕。</p><p>另外，这里还隐含了一个设计选择：Rust 永远也不会自动创建数据的 “深拷贝”。因此，任何 <strong>自动</strong> 的复制可以被认为对运行时性能影响较小。</p>`,27),cn={id:"变量与数据交互的方式-二-克隆",tabindex:"-1"},ln=n("a",{class:"header-anchor",href:"#变量与数据交互的方式-二-克隆","aria-hidden":"true"},"#",-1),rn={href:"https://www.rustwiki.org.cn/zh-CN/book/ch04-01-what-is-ownership.html#%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E7%9A%84%E6%96%B9%E5%BC%8F%E4%BA%8C%E5%85%8B%E9%9A%86",target:"_blank",rel:"noopener noreferrer"},un=t(`<p>如果我们 <strong>确实</strong> 需要深度复制 <code>String</code> 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 <code>clone</code> 的通用函数。第 5 章会讨论方法语法，不过因为方法在很多语言中是一个常见功能，所以之前你可能已经见过了。</p><p>这是一个实际使用 <code>clone</code> 方法的例子：</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code>    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;s1 = {}, s2 = {}&quot;</span><span class="token punctuation">,</span> s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码能正常运行，并且明确产生图 4-3 中行为，这里堆上的数据 <strong>确实</strong> 被复制了。</p><p>当出现 <code>clone</code> 调用时，你知道一些特定的代码被执行而且这些代码可能相当消耗资源。你很容易察觉到一些不寻常的事情正在发生。</p>`,5),dn={id:"只在栈上的数据-拷贝",tabindex:"-1"},kn=n("a",{class:"header-anchor",href:"#只在栈上的数据-拷贝","aria-hidden":"true"},"#",-1),mn={href:"https://www.rustwiki.org.cn/zh-CN/book/ch04-01-what-is-ownership.html#%E5%8F%AA%E5%9C%A8%E6%A0%88%E4%B8%8A%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8B%B7%E8%B4%9D",target:"_blank",rel:"noopener noreferrer"},vn=t(`<p>这里还有一个没有提到的小窍门。这些代码使用了整型并且是有效的，他们是示例 4-2 中的一部分：</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code>    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;x = {}, y = {}&quot;</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但这段代码似乎与我们刚刚学到的内容相矛盾：没有调用 <code>clone</code>，不过 <code>x</code> 依然有效且没有被移动到 <code>y</code> 中。</p><p>原因是像整型这样的在编译时已知大小的类型被整个存储在栈上，所以拷贝其实际的值是快速的。这意味着没有理由在创建变量 <code>y</code> 后使 <code>x</code> 无效。换句话说，这里没有深浅拷贝的区别，所以这里调用 <code>clone</code> 并不会与通常的浅拷贝有什么不同，我们可以不用管它。</p>`,4),hn=n("code",null,"Copy",-1),gn=n("code",null,"Copy",-1),bn=n("code",null,"Drop",-1),_n=n("code",null,"Copy",-1),wn=n("code",null,"Copy",-1),fn=n("code",null,"Copy",-1),En={href:"https://www.rustwiki.org.cn/zh-CN/book/appendix-03-derivable-traits.html",target:"_blank",rel:"noopener noreferrer"},yn=t("<p>那么哪些类型实现了 <code>Copy</code> trait 呢？你可以查看给定类型的文档来确认，不过作为一个通用的规则，任何一组简单标量值的组合都可以实现 <code>Copy</code>，任何不需要分配内存或某种形式资源的类型都可以实现 <code>Copy</code> 。如下是一些 <code>Copy</code> 的类型：</p><ul><li>所有整数类型，比如 <code>u32</code>。</li><li>布尔类型，<code>bool</code>，它的值是 <code>true</code> 和 <code>false</code>。</li><li>所有浮点数类型，比如 <code>f64</code>。</li><li>字符类型，<code>char</code>。</li><li>元组，当且仅当其包含的类型也都实现 <code>Copy</code> 的时候。比如，<code>(i32, i32)</code> 实现了 <code>Copy</code>，但 <code>(i32, String)</code> 就没有。</li></ul>",2),xn={id:"所有权与函数",tabindex:"-1"},qn=n("a",{class:"header-anchor",href:"#所有权与函数","aria-hidden":"true"},"#",-1),Cn={href:"https://www.rustwiki.org.cn/zh-CN/book/ch04-01-what-is-ownership.html#%E6%89%80%E6%9C%89%E6%9D%83%E4%B8%8E%E5%87%BD%E6%95%B0",target:"_blank",rel:"noopener noreferrer"},Bn=t(`<p>将值传递给函数在语义上与给变量赋值相似。向函数传递值可能会移动或者复制，就像赋值语句一样。示例 4-3 使用注释展示变量何时进入和离开作用域：</p><p>文件名: src/main.rs</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// s 进入作用域</span>

  <span class="token function">takes_ownership</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// s 的值移动到函数里 ...</span>
                                  <span class="token comment">// ... 所以到这里不再有效</span>

  <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>                      <span class="token comment">// x 进入作用域</span>

  <span class="token function">makes_copy</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// x 应该移动函数里，</span>
                                  <span class="token comment">// 但 i32 是 Copy 的，所以在后面可继续使用 x</span>

<span class="token punctuation">}</span> <span class="token comment">// 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，</span>
  <span class="token comment">// 所以不会有特殊操作</span>

<span class="token keyword">fn</span> <span class="token function-definition function">takes_ownership</span><span class="token punctuation">(</span>some_string<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// some_string 进入作用域</span>
  <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{}&quot;</span><span class="token punctuation">,</span> some_string<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token comment">// 这里，some_string 移出作用域并调用 \`drop\` 方法。占用的内存被释放</span>

<span class="token keyword">fn</span> <span class="token function-definition function">makes_copy</span><span class="token punctuation">(</span>some_integer<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// some_integer 进入作用域</span>
  <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{}&quot;</span><span class="token punctuation">,</span> some_integer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token comment">// 这里，some_integer 移出作用域。不会有特殊操作</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>示例 4-3：带有所有权和作用域注释的函数</p><p>当尝试在调用 <code>takes_ownership</code> 后使用 <code>s</code> 时，Rust 会抛出一个编译时错误。这些静态检查使我们免于犯错。试试在 <code>main</code> 函数中添加使用 <code>s</code> 和 <code>x</code> 的代码来看看哪里能使用他们，以及所有权规则会在哪里阻止我们这么做。</p>`,5),Sn={id:"返回值与作用域",tabindex:"-1"},An=n("a",{class:"header-anchor",href:"#返回值与作用域","aria-hidden":"true"},"#",-1),Rn={href:"https://www.rustwiki.org.cn/zh-CN/book/ch04-01-what-is-ownership.html#%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F",target:"_blank",rel:"noopener noreferrer"},Nn=t(`<p>返回值也可以转移所有权。示例 4-4 与示例 4-3 一样带有类似的注释。</p><p>文件名: src/main.rs</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token function">gives_ownership</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// gives_ownership 将返回值</span>
                                      <span class="token comment">// 移给 s1</span>

  <span class="token keyword">let</span> s2 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// s2 进入作用域</span>

  <span class="token keyword">let</span> s3 <span class="token operator">=</span> <span class="token function">takes_and_gives_back</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// s2 被移动到</span>
                                      <span class="token comment">// takes_and_gives_back 中,</span>
                                      <span class="token comment">// 它也将返回值移给 s3</span>
<span class="token punctuation">}</span> <span class="token comment">// 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，</span>
  <span class="token comment">// 所以什么也不会发生。s1 移出作用域并被丢弃</span>

<span class="token keyword">fn</span> <span class="token function-definition function">gives_ownership</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">String</span> <span class="token punctuation">{</span>           <span class="token comment">// gives_ownership 将返回值移动给</span>
                                           <span class="token comment">// 调用它的函数</span>

  <span class="token keyword">let</span> some_string <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;yours&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// some_string 进入作用域</span>

  some_string                              <span class="token comment">// 返回 some_string 并移出给调用的函数</span>
<span class="token punctuation">}</span>

<span class="token comment">// takes_and_gives_back 将传入字符串并返回该值</span>
<span class="token keyword">fn</span> <span class="token function-definition function">takes_and_gives_back</span><span class="token punctuation">(</span>a_string<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">String</span> <span class="token punctuation">{</span> <span class="token comment">// a_string 进入作用域</span>

  a_string  <span class="token comment">// 返回 a_string 并移出给调用的函数</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>示例 4-4: 转移返回值的所有权</p><p>变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它。当持有堆中数据值的变量离开作用域时，其值将通过 <code>drop</code> 被清理掉，除非数据被移动为另一个变量所有。</p><p>在每一个函数中都获取所有权并接着返回所有权有些啰嗦。如果我们想要函数使用一个值但不获取所有权该怎么办呢？如果我们还要接着使用它的话，每次都传进去再返回来就有点烦人了，除此之外，我们也可能想返回函数体中产生的一些数据。</p><p>我们可以使用元组来返回多个值，如示例 4-5 所示。</p><p>文件名: src/main.rs</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> <span class="token punctuation">(</span>s2<span class="token punctuation">,</span> len<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">calculate_length</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;The length of &#39;{}&#39; is {}.&quot;</span><span class="token punctuation">,</span> s2<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">calculate_length</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token keyword">usize</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> length <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// len() 返回字符串的长度</span>

    <span class="token punctuation">(</span>s<span class="token punctuation">,</span> length<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>示例 4-5: 返回参数的所有权</p><p>但是这未免有些形式主义，而且这种场景应该很常见。幸运的是，Rust 对此提供了一个功能，叫做 <strong>引用</strong>（<em>references</em>）。</p><h2 id="补充" tabindex="-1"><a class="header-anchor" href="#补充" aria-hidden="true">#</a> 补充</h2><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">let</span> string <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 所有权转移到s</span>
    <span class="token keyword">let</span> s <span class="token operator">=</span> string<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// string 不可用了</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">let</span> string <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 注意，这是个表达式，其所有权也被转移到某个临时变量了</span>
    string<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// string 不可用了</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">let</span> string <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">{</span>
    <span class="token comment">// _是占位符，此处赋值会被忽略，所以并没有发生所有权转移</span>
    <span class="token keyword">let</span> _ <span class="token operator">=</span> string<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// string 仍然可用</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,15);function zn(Fn,Dn){const a=p("ExternalLinkIcon");return c(),i("div",null,[r,u,n("h2",d,[k,s(),n("a",m,[s("什么是所有权？"),e(a)])]),v,h,g,b,n("blockquote",null,[n("h3",_,[w,s(),n("a",f,[s("栈（Stack）与堆（Heap）"),e(a)])]),E]),n("h3",y,[x,s(),n("a",q,[s("所有权规则"),e(a)])]),C,B,n("h3",S,[A,s(),n("a",R,[s("变量作用域"),e(a)])]),N,n("h3",z,[F,s(),n("a",D,[I,s(" 类型"),e(a)])]),V,n("p",null,[s("这两个冒号（"),G,s("）是运算符，允许将特定的 "),L,s(" 函数置于 "),T,s(" 类型的命名空间（namespace）下，而不需要使用类似 "),j,s(" 这样的名字。在第 5 章的"),n("a",H,[s("“方法语法”（“Method Syntax”）"),e(a)]),s("部分会着重讲解这个语法而且在第 7 章的"),n("a",M,[s("“路径用于引用模块树中的项”"),e(a)]),s("中会讲到模块的命名空间。")]),$,n("h3",J,[K,s(),n("a",O,[s("内存与分配"),e(a)])]),P,n("p",null,[s("这是一个将 "),Q,s(" 需要的内存返回给分配器的很自然的位置：当 "),U,s(" 离开作用域的时候。当变量离开作用域，Rust 为我们调用一个特殊的函数。这个函数叫做 "),n("a",W,[X,e(a)]),s("，在这里 "),Y,s(" 的作者可以放置释放内存的代码。Rust 在结尾的 "),Z,s(" 处自动调用 "),nn,s("。")]),sn,an,n("h4",en,[tn,s(),n("a",on,[s("变量与数据交互的方式（一）：移动"),e(a)])]),pn,n("h4",cn,[ln,s(),n("a",rn,[s("变量与数据交互的方式（二）：克隆"),e(a)])]),un,n("h4",dn,[kn,s(),n("a",mn,[s("只在栈上的数据：拷贝"),e(a)])]),vn,n("p",null,[s("Rust 有一个叫做 "),hn,s(" trait 的特殊标注，可以用在类似整型这样的存储在栈上的类型上（第 10 章详细讲解 trait）。如果一个类型实现了 "),gn,s(" trait，那么一个旧的变量在将其赋值给其他变量后仍然可用。Rust 不允许自身或其任何部分实现了 "),bn,s(" trait 的类型使用 "),_n,s(" trait。如果我们对其值离开作用域时需要特殊处理的类型使用 "),wn,s(" 标注，将会出现一个编译时错误。要学习如何为你的类型添加 "),fn,s(" 标注以实现该 trait，请阅读附录 C 中的 "),n("a",En,[s("“可派生的 trait”"),e(a)]),s("。")]),yn,n("h3",xn,[qn,s(),n("a",Cn,[s("所有权与函数"),e(a)])]),Bn,n("h3",Sn,[An,s(),n("a",Rn,[s("返回值与作用域"),e(a)])]),Nn])}const Vn=o(l,[["render",zn],["__file","20240411-Rust-06-suoyouquan.html.vue"]]);export{Vn as default};
