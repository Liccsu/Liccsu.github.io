import{_ as o,r as c,o as p,c as i,a as n,b as s,d as e,e as t}from"./app-C4bsKav7.js";const l={},u=n("h1",{id:"结构体",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#结构体","aria-hidden":"true"},"#"),s(" 结构体")],-1),d={id:"定义并实例化结构体",tabindex:"-1"},r=n("a",{class:"header-anchor",href:"#定义并实例化结构体","aria-hidden":"true"},"#",-1),k={href:"https://www.rustwiki.org.cn/zh-CN/book/ch05-01-defining-structs.html#%E5%AE%9A%E4%B9%89%E5%B9%B6%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%BB%93%E6%9E%84%E4%BD%93",target:"_blank",rel:"noopener noreferrer"},m={href:"https://www.rustwiki.org.cn/zh-CN/book/ch03-02-data-types.html#%E5%85%83%E7%BB%84%E7%B1%BB%E5%9E%8B",target:"_blank",rel:"noopener noreferrer"},v=t(`<p>定义结构体，需要使用 <code>struct</code> 关键字并为整个结构体提供一个名字。结构体的名字需要描述它所组合的数据的意义。接着，在大括号中，定义每一部分数据的名字和类型，我们称为 <strong>字段</strong>（<em>field</em>）。例如，示例 5-1 展示了一个存储用户账号信息的结构体：</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">struct</span> <span class="token type-definition class-name">User</span> <span class="token punctuation">{</span>
    active<span class="token punctuation">:</span> <span class="token keyword">bool</span><span class="token punctuation">,</span>
    username<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span>
    email<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span>
    sign_in_count<span class="token punctuation">:</span> <span class="token keyword">u64</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>示例 5-1：<code>User</code> 结构体定义</p><p>一旦定义了结构体后，为了使用它，通过为每个字段指定具体值来创建这个结构体的<strong>实例</strong>。创建一个实例需要以结构体的名字开头，接着在大括号中使用 <code>key: value</code> 键-值对的形式提供字段，其中 key 是字段的名字，value 是需要存储在字段中的数据值。实例中字段的顺序不需要和它们在结构体中声明的顺序一致。换句话说，结构体的定义就像一个类型的通用模板，而实例则会在这个模板中放入特定数据来创建这个类型的值。例如，可以像示例 5-2 这样来声明一个特定的用户：</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> user1 <span class="token operator">=</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
        email<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;someone@example.com&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        username<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;someusername123&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        active<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
        sign_in_count<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>示例 5-2：创建 <code>User</code> 结构体的实例</p><p>为了从结构体中获取某个特定的值，可以使用点号。如果我们只想要用户的邮箱地址，可以用 <code>user1.email</code>。要更改结构体中的值，如果结构体的实例是可变的，我们可以使用点号并为对应的字段赋值。示例 5-3 展示了如何改变一个可变的 <code>User</code> 实例 <code>email</code> 字段的值：</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> user1 <span class="token operator">=</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
        email<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;someone@example.com&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        username<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;someusername123&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        active<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
        sign_in_count<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    user1<span class="token punctuation">.</span>email <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;anotheremail@example.com&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>示例 5-3：改变 <code>User</code> 实例 <code>email</code> 字段的值</p><p>注意整个实例必须是可变的；Rust 并不允许只将某个字段标记为可变。另外需要注意同其他任何表达式一样，我们可以在函数体的最后一个表达式中构造一个结构体的新实例，来隐式地返回这个实例。</p><p>示例 5-4 显示了一个 <code>build_user</code> 函数，它返回一个带有给定的 email 和用户名的 <code>User</code> 结构体实例。<code>active</code> 字段的值为 <code>true</code>，并且 <code>sign_in_count</code> 的值为 <code>1</code>。</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">build_user</span><span class="token punctuation">(</span>email<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> username<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
    <span class="token class-name">User</span> <span class="token punctuation">{</span>
        email<span class="token punctuation">:</span> email<span class="token punctuation">,</span>
        username<span class="token punctuation">:</span> username<span class="token punctuation">,</span>
        active<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
        sign_in_count<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>示例 5-4：<code>build_user</code> 函数获取 email 和用户名并返回 <code>User</code> 实例</p><p>为函数参数起与结构体字段相同的名字是可以理解的，但是不得不重复 <code>email</code> 和 <code>username</code> 字段名称与变量有些啰嗦。如果结构体有更多字段，重复每个名称就更加烦人了。幸运的是，有一个方便的简写语法！</p>`,14),b={id:"变量与字段同名时的字段初始化简写语法",tabindex:"-1"},h=n("a",{class:"header-anchor",href:"#变量与字段同名时的字段初始化简写语法","aria-hidden":"true"},"#",-1),g={href:"https://www.rustwiki.org.cn/zh-CN/book/ch05-01-defining-structs.html#%E5%8F%98%E9%87%8F%E4%B8%8E%E5%AD%97%E6%AE%B5%E5%90%8C%E5%90%8D%E6%97%B6%E7%9A%84%E5%AD%97%E6%AE%B5%E5%88%9D%E5%A7%8B%E5%8C%96%E7%AE%80%E5%86%99%E8%AF%AD%E6%B3%95",target:"_blank",rel:"noopener noreferrer"},f=t(`<p>因为示例 5-4 中的参数名与字段名都完全相同，我们可以使用<strong>字段初始化简写语法</strong>（<em>field init shorthand</em>）来重写 <code>build_user</code>，这样其行为与之前完全相同，不过无需重复 <code>email</code> 和 <code>username</code> 了，如示例 5-5 所示。</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">build_user</span><span class="token punctuation">(</span>email<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> username<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
    <span class="token class-name">User</span> <span class="token punctuation">{</span>
        email<span class="token punctuation">,</span>
        username<span class="token punctuation">,</span>
        active<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
        sign_in_count<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>示例 5-5：<code>build_user</code> 函数使用了字段初始化简写语法，因为 <code>email</code> 和 <code>username</code> 参数与结构体字段同名</p><p>这里我们创建了一个新的 <code>User</code> 结构体实例，它有一个叫做 <code>email</code> 的字段。我们想要将 <code>email</code> 字段的值设置为 <code>build_user</code> 函数 <code>email</code> 参数的值。因为 <code>email</code> 字段与 <code>email</code> 参数有着相同的名称，则只需编写 <code>email</code> 而不是 <code>email: email</code>。</p>`,4),_={id:"使用结构体更新语法从其他实例创建实例",tabindex:"-1"},E=n("a",{class:"header-anchor",href:"#使用结构体更新语法从其他实例创建实例","aria-hidden":"true"},"#",-1),w={href:"https://www.rustwiki.org.cn/zh-CN/book/ch05-01-defining-structs.html#%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E6%9B%B4%E6%96%B0%E8%AF%AD%E6%B3%95%E4%BB%8E%E5%85%B6%E4%BB%96%E5%AE%9E%E4%BE%8B%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B",target:"_blank",rel:"noopener noreferrer"},B=t(`<p>使用旧实例的大部分值但改变其部分值来创建一个新的结构体实例通常很有用。这可以通过<strong>结构体更新语法</strong>（<em>struct update syntax</em>）实现。</p><p>首先，示例 5-6 展示了不使用更新语法时，如何在 <code>user2</code> 中创建一个新 <code>User</code> 实例。我们为 <code>email</code> 设置了新的值，其他值则使用了实例 5-2 中创建的 <code>user1</code> 中的同名值：</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// --snip--</span>

    <span class="token keyword">let</span> user2 <span class="token operator">=</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
        active<span class="token punctuation">:</span> user1<span class="token punctuation">.</span>active<span class="token punctuation">,</span>
        username<span class="token punctuation">:</span> user1<span class="token punctuation">.</span>username<span class="token punctuation">,</span>
        email<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;another@example.com&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        sign_in_count<span class="token punctuation">:</span> user1<span class="token punctuation">.</span>sign_in_count<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>示例 5-6：使用 <code>user1</code> 中的一个值创建一个新的 <code>User</code> 实例</p><p>使用结构体更新语法，我们可以通过更少的代码来达到相同的效果，如示例 5-7 所示。<code>..</code> 语法指定了剩余未显式设置值的字段应有与给定实例对应字段相同的值。</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// --snip--</span>

    <span class="token keyword">let</span> user2 <span class="token operator">=</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
        email<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;another@example.com&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">..</span>user1
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>示例 5-7：使用结构体更新语法为一个 <code>User</code> 实例设置一个新的 <code>email</code> 值，不过其余值来自 <code>user1</code> 变量中实例的字段</p><p>示例 5-7 中的代码也在 <code>user2</code> 中创建了一个新实例，其有不同的 <code>email</code> 值，不过 <code>username</code>、 <code>active</code> 和 <code>sign_in_count</code> 字段的值与 <code>user1</code> 相同。<code>..user1</code> 必须放在最后，以指定其余的字段应从 <code>user1</code> 的相应字段中获取其值，但我们可以选择以任何顺序为任意字段指定值，而不用考虑结构体定义中字段的顺序。</p>`,8),y=n("code",null,"=",-1),A={href:"https://www.rustwiki.org.cn/zh-CN/book/ch04-01-what-is-ownership.html#%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E7%9A%84%E6%96%B9%E5%BC%8F%E4%B8%80%E7%A7%BB%E5%8A%A8",target:"_blank",rel:"noopener noreferrer"},x=n("code",null,"user2",-1),C=n("code",null,"user1",-1),q=n("code",null,"user1",-1),D=n("code",null,"username",-1),S=n("code",null,"String",-1),U=n("code",null,"user2",-1),R=n("code",null,"user2",-1),N=n("code",null,"email",-1),F=n("code",null,"username",-1),z=n("code",null,"String",-1),T=n("code",null,"user1",-1),j=n("code",null,"active",-1),P=n("code",null,"sign_in_count",-1),V=n("code",null,"user1",-1),W=n("code",null,"user2",-1),L=n("code",null,"active",-1),I=n("code",null,"sign_in_count",-1),J=n("code",null,"Copy",-1),$={href:"https://www.rustwiki.org.cn/zh-CN/book/ch04-01-what-is-ownership.html#%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E7%9A%84%E6%96%B9%E5%BC%8F%E4%BA%8C%E5%85%8B%E9%9A%86",target:"_blank",rel:"noopener noreferrer"},G={id:"使用没有命名字段的元组结构体来创建不同的类型",tabindex:"-1"},H=n("a",{class:"header-anchor",href:"#使用没有命名字段的元组结构体来创建不同的类型","aria-hidden":"true"},"#",-1),K={href:"https://www.rustwiki.org.cn/zh-CN/book/ch05-01-defining-structs.html#%E4%BD%BF%E7%94%A8%E6%B2%A1%E6%9C%89%E5%91%BD%E5%90%8D%E5%AD%97%E6%AE%B5%E7%9A%84%E5%85%83%E7%BB%84%E7%BB%93%E6%9E%84%E4%BD%93%E6%9D%A5%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%90%8C%E7%9A%84%E7%B1%BB%E5%9E%8B",target:"_blank",rel:"noopener noreferrer"},M=t(`<p>也可以定义与元组（在第 3 章讨论过）类似的结构体，称为<strong>元组结构体</strong>（<em>tuple struct</em>）。元组结构体有着结构体名称提供的含义，但没有具体的字段名，只有字段的类型。当你想给整个元组取一个名字，并使元组成为与其他元组不同的类型时，元组结构体是很有用的，这时像常规结构体那样为每个字段命名就显得多余和形式化了。</p><p>要定义元组结构体，以 <code>struct</code> 关键字和结构体名开头并后跟元组中的类型。例如，下面是两个分别叫做 <code>Color</code> 和 <code>Point</code> 元组结构体的定义和用法：</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">struct</span> <span class="token type-definition class-name">Color</span><span class="token punctuation">(</span><span class="token keyword">i32</span><span class="token punctuation">,</span> <span class="token keyword">i32</span><span class="token punctuation">,</span> <span class="token keyword">i32</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token type-definition class-name">Point</span><span class="token punctuation">(</span><span class="token keyword">i32</span><span class="token punctuation">,</span> <span class="token keyword">i32</span><span class="token punctuation">,</span> <span class="token keyword">i32</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> black <span class="token operator">=</span> <span class="token class-name">Color</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> origin <span class="token operator">=</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意 <code>black</code> 和 <code>origin</code> 值的类型不同，因为它们是不同的元组结构体的实例。你定义的每一个结构体有其自己的类型，即使结构体中的字段有着相同的类型。例如，一个获取 <code>Color</code> 类型参数的函数不能接受 <code>Point</code> 作为参数，即便这两个类型都由三个 <code>i32</code> 值组成。在其他方面，元组结构体实例类似于元组：可以将其解构为单独的部分，也可以使用 <code>.</code> 后跟索引来访问单独的值，等等。</p>`,4),O={id:"没有任何字段的类单元结构体",tabindex:"-1"},Q=n("a",{class:"header-anchor",href:"#没有任何字段的类单元结构体","aria-hidden":"true"},"#",-1),X={href:"https://www.rustwiki.org.cn/zh-CN/book/ch05-01-defining-structs.html#%E6%B2%A1%E6%9C%89%E4%BB%BB%E4%BD%95%E5%AD%97%E6%AE%B5%E7%9A%84%E7%B1%BB%E5%8D%95%E5%85%83%E7%BB%93%E6%9E%84%E4%BD%93",target:"_blank",rel:"noopener noreferrer"},Y=n("strong",null,"类单元结构体",-1),Z=n("em",null,"unit-like structs",-1),nn=n("code",null,"()",-1),sn={href:"https://www.rustwiki.org.cn/zh-CN/book/ch03-02-data-types.html#%E5%85%83%E7%BB%84%E7%B1%BB%E5%9E%8B",target:"_blank",rel:"noopener noreferrer"},an=n("code",null,"AlwaysEqual",-1),en=t(`<div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">struct</span> <span class="token type-definition class-name">AlwaysEqual</span><span class="token punctuation">;</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> subject <span class="token operator">=</span> <span class="token class-name">AlwaysEqual</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>要定义 <code>AlwaysEqual</code>，我们使用 <code>struct</code> 关键字，我们想要的名称，然后是一个分号。不需要花括号或圆括号！然后，我们可以以类似的方式在 <code>subject</code> 变量中获得 <code>AlwaysEqual</code> 的实例：使用我们定义的名称，不需要任何花括号或圆括号。想象一下，我们将实现这个类型的行为，即每个实例始终等于每一个其他类型的实例，也许是为了获得一个已知的结果以便进行测试。我们不需要任何数据来实现这种行为，你将在第十章中，看到如何定义特性并在任何类型上实现它们，包括类单元结构体。</p>`,2),tn={id:"结构体数据的所有权",tabindex:"-1"},on=n("a",{class:"header-anchor",href:"#结构体数据的所有权","aria-hidden":"true"},"#",-1),cn={href:"https://www.rustwiki.org.cn/zh-CN/book/ch05-01-defining-structs.html#%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E6%8D%AE%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83",target:"_blank",rel:"noopener noreferrer"},pn=t(`<p>在示例 5-1 中的 <code>User</code> 结构体的定义中，我们使用了自身拥有所有权的 <code>String</code> 类型而不是 <code>&amp;str</code> 字符串 slice 类型。这是一个有意而为之的选择，因为我们想要这个结构体拥有它所有的数据，为此只要整个结构体是有效的话其数据也是有效的。</p><p>可以使结构体存储被其他对象拥有的数据的引用，不过这么做的话需要用上<strong>生命周期</strong>（<em>lifetime</em>），这是一个第 10 章会讨论的 Rust 功能。生命周期确保结构体引用的数据有效性跟结构体本身保持一致。如果你尝试在结构体中存储一个引用而不指定生命周期将是无效的，比如这样：</p><p>文件名: src/main.rs</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">struct</span> <span class="token type-definition class-name">User</span> <span class="token punctuation">{</span>
    active<span class="token punctuation">:</span> <span class="token keyword">bool</span><span class="token punctuation">,</span>
    username<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">,</span>
    email<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">,</span>
    sign_in_count<span class="token punctuation">:</span> <span class="token keyword">u64</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> user1 <span class="token operator">=</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
        email<span class="token punctuation">:</span> <span class="token string">&quot;someone@example.com&quot;</span><span class="token punctuation">,</span>
        username<span class="token punctuation">:</span> <span class="token string">&quot;someusername123&quot;</span><span class="token punctuation">,</span>
        active<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
        sign_in_count<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编译器会抱怨它需要生命周期标识符：</p><div class="language-console line-numbers-mode" data-ext="console"><pre class="language-console"><code>$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:3:15
  |
3 |     username: &amp;str,
  |               ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User&lt;&#39;a&gt; {
2 |     active: bool,
3 ~     username: &amp;&#39;a str,
  |

error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:4:12
  |
4 |     email: &amp;str,
  |            ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User&lt;&#39;a&gt; {
2 |     active: bool,
3 |     username: &amp;str,
4 ~     email: &amp;&#39;a str,
  |

For more information about this error, try \`rustc --explain E0106\`.
error: could not compile \`structs\` due to 2 previous errors
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第 10 章会讲到如何修复这个问题以便在结构体中存储引用，不过现在，我们会使用像 <code>String</code> 这类拥有所有权的类型来替代 <code>&amp;str</code> 这样的引用以修正这个错误。</p>`,7),ln=t(`<h2 id="补充" tabindex="-1"><a class="header-anchor" href="#补充" aria-hidden="true">#</a> 补充</h2><p>类单元结构体（Unit-Like Structs）在Rust中是一种特殊的结构体，它不包含任何字段。这种结构体的语法非常简单，只需要关键字<code>struct</code>后跟结构体的名称和一个分号。这种结构体因为形似于单元类型<code>()</code>而得名，单元类型是一个不包含任何值的特殊类型，通常用于表示一个函数没有返回值。</p><p>类单元结构体的用途主要包括：</p><ol><li><p><strong>标记使用</strong>：它们可以用作标记，携带类型信息而不实际存储任何数据。这可以用于类型安全的标记某些状态或行为，而不需要额外的数据。</p></li><li><p><strong>实现特质（Trait）</strong>：虽然类单元结构体本身不存储数据，但它们可以实现特质（Traits），这允许在不需要存储数据的情况下，为某个类型提供特定的行为。</p></li></ol><h3 id="示例1-使用作为标记" tabindex="-1"><a class="header-anchor" href="#示例1-使用作为标记" aria-hidden="true">#</a> 示例1：使用作为标记</h3><p>考虑一个场景，你设计了一个图形渲染库，需要区分不同种类的渲染模式，但是这些模式本身不需要存储任何状态信息：</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">struct</span> <span class="token type-definition class-name">SolidRendering</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token type-definition class-name">WireframeRendering</span><span class="token punctuation">;</span>

<span class="token keyword">trait</span> <span class="token type-definition class-name">Render</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">render</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span> <span class="token class-name">Render</span> <span class="token keyword">for</span> <span class="token class-name">SolidRendering</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">render</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Rendering in solid mode.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span> <span class="token class-name">Render</span> <span class="token keyword">for</span> <span class="token class-name">WireframeRendering</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">render</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Rendering in wireframe mode.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">render_scene</span><span class="token punctuation">(</span>mode<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">dyn</span> <span class="token class-name">Render</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    mode<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> solid <span class="token operator">=</span> <span class="token class-name">SolidRendering</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> wireframe <span class="token operator">=</span> <span class="token class-name">WireframeRendering</span><span class="token punctuation">;</span>

    <span class="token function">render_scene</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>solid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">render_scene</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wireframe<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，<code>SolidRendering</code> 和 <code>WireframeRendering</code> 是类单元结构体，它们用作渲染模式的标记。我们为它们实现了<code>Render</code>特质，使得可以根据不同的渲染模式调用不同的<code>render</code>方法。</p><h3 id="示例2-在单元测试中的使用" tabindex="-1"><a class="header-anchor" href="#示例2-在单元测试中的使用" aria-hidden="true">#</a> 示例2：在单元测试中的使用</h3><p>类单元结构体可以在单元测试中用作测试标记，以区分不同的测试配置或环境：</p><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">struct</span> <span class="token type-definition class-name">TestConfig</span><span class="token punctuation">;</span>

<span class="token keyword">impl</span> <span class="token class-name">TestConfig</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">Self</span> <span class="token punctuation">{</span>
        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Creating test configuration...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">TestConfig</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">setup</span><span class="token punctuation">(</span>config<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">TestConfig</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Setting up tests...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> config <span class="token operator">=</span> <span class="token class-name">TestConfig</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setup</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 进行测试</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>TestConfig</code> 类单元结构体用于创建和传递测试配置，即使它实际上不包含任何数据。这种方法可以用于在测试代码中传递配置标记，而无需关心具体的配置数据。</p><p>总之，类单元结构体在Rust中是一种用于表示没有数据只有类型的结构体。它们在作为标记、实现特质等方面提供了简洁而强大的用途。</p>`,13);function un(dn,rn){const a=c("ExternalLinkIcon");return p(),i("div",null,[u,n("h2",d,[r,s(),n("a",k,[s("定义并实例化结构体"),e(a)])]),n("p",null,[s("结构体和我们在"),n("a",m,[s("“元组类型”"),e(a)]),s("章节论过的元组类似。和元组一样，结构体的每一部分可以是不同类型。但不同于元组，结构体需要命名各部分数据以便能清楚的表明其值的意义。由于有了这些名字，结构体比元组更灵活：不需要依赖顺序来指定或访问实例中的值。")]),v,n("h3",b,[h,s(),n("a",g,[s("变量与字段同名时的字段初始化简写语法"),e(a)])]),f,n("h3",_,[E,s(),n("a",w,[s("使用结构体更新语法从其他实例创建实例"),e(a)])]),B,n("p",null,[s("请注意，结构更新语法就像带有 "),y,s(" 的赋值，因为它移动了数据，就像我们在"),n("a",A,[s("“变量与数据交互的方式（一）：移动”"),e(a)]),s("部分讲到的一样。在这个例子中，我们在创建 "),x,s(" 后不能再使用 "),C,s("，因为 "),q,s(" 的 "),D,s(" 字段中的 "),S,s(" 被移到 "),U,s(" 中。如果我们给 "),R,s(" 的 "),N,s(" 和 "),F,s(" 都赋予新的 "),z,s(" 值，从而只使用 "),T,s(" 的 "),j,s(" 和 "),P,s(" 值，那么 "),V,s(" 在创建 "),W,s(" 后仍然有效。"),L,s(" 和 "),I,s(" 的类型是实现 "),J,s(" trait 的类型，所以我们在"),n("a",$,[s("“变量与数据交互的方式（二）：克隆”"),e(a)]),s("部分讨论的行为同样适用。")]),n("h3",G,[H,s(),n("a",K,[s("使用没有命名字段的元组结构体来创建不同的类型"),e(a)])]),M,n("h3",O,[Q,s(),n("a",X,[s("没有任何字段的类单元结构体"),e(a)])]),n("p",null,[s("我们也可以定义一个没有任何字段的结构体！它们被称为"),Y,s("（"),Z,s("），因为它们类似于 "),nn,s("，即"),n("a",sn,[s("“元组类型”"),e(a)]),s("一节中提到的 unit 类型。类单元结构体常常在你想要在某个类型上实现 trait 但不需要在类型中存储数据的时候发挥作用。我们将在第 10 章介绍 trait。下面是一个声明和实例化一个名为 "),an,s(" 的 unit 结构的例子。")]),en,n("blockquote",null,[n("h3",tn,[on,s(),n("a",cn,[s("结构体数据的所有权"),e(a)])]),pn]),ln])}const mn=o(l,[["render",un],["__file","20240413-Rust-09-jiegouti.html.vue"]]);export{mn as default};
